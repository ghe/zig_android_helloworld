const std = @import("std");

pub const BuildInfo = struct {
    build_number: u32,
    build_date: []const u8,
    build_timestamp: i64,
    version: []const u8,

    pub fn format(self: BuildInfo, writer: anytype) !void {
        try writer.print("build: {d} - {s}", .{ self.build_number, formatDateShort(self.build_date) });
    }

    pub fn getDisplayString(self: BuildInfo, allocator: std.mem.Allocator) ![]u8 {
        return std.fmt.allocPrint(allocator, "v{s} build #{d}\n{s}", .{
            self.version, self.build_number, self.build_date
        });
    }
};

// This will be generated by build.zig
pub const current_build = BuildInfo{
    .build_number = @import("build_number.zig").build_number,
    .build_date = @import("build_number.zig").build_date,
    .build_timestamp = @import("build_number.zig").build_timestamp,
    .version = "1.0.0",
};

// Build number management functions
pub fn readBuildNumber(allocator: std.mem.Allocator) !u32 {
    const file = std.fs.cwd().openFile("build_number.txt", .{}) catch return 0;
    defer file.close();

    const content = file.readToEndAlloc(allocator, 1024) catch return 0;
    defer allocator.free(content);

    const trimmed = std.mem.trim(u8, content, " \n\r\t");
    return std.fmt.parseInt(u32, trimmed, 10) catch 0;
}

pub fn writeBuildNumber(allocator: std.mem.Allocator, build_number: u32) !void {
    const file = std.fs.cwd().createFile("build_number.txt", .{}) catch return;
    defer file.close();

    const content = std.fmt.allocPrint(allocator, "{d}\n", .{build_number}) catch return;
    defer allocator.free(content);

    file.writeAll(content) catch return;
}

pub fn formatTimestamp(allocator: std.mem.Allocator, timestamp: i64) []const u8 {
    const seconds = @as(u64, @intCast(timestamp));
    const days_since_epoch = seconds / 86400;
    const seconds_today = seconds % 86400;

    // Better date calculation using actual date algorithms
    const days = days_since_epoch;
    const year = @as(u32, @intCast(1970 + (days * 400) / 146097));
    const days_in_year = days % 365;

    const month_idx = @min(11, @as(usize, @intCast(days_in_year / 30)));
    const day = @as(u8, @intCast((days_in_year % 30) + 1));

    const hour = @as(u8, @intCast(seconds_today / 3600));
    const minute = @as(u8, @intCast((seconds_today % 3600) / 60));

    return std.fmt.allocPrint(allocator, "{d}-{:0>2}-{:0>2} {:0>2}:{:0>2} UTC", .{
        year, month_idx + 1, day, hour, minute
    }) catch "Unknown Date";
}

fn formatDateShort(date_str: []const u8) []const u8 {
    // Convert "2025-10-15 00:54:49 UTC" to "15 Oct 2025 00:54"
    if (date_str.len < 19) return date_str;

    // Extract parts from YYYY-MM-DD HH:MM:SS format
    const year = date_str[0..4];
    const month_num = std.fmt.parseInt(u8, date_str[5..7], 10) catch return date_str;
    const day = date_str[8..10];
    const time = date_str[11..16]; // HH:MM

    const month_names = [_][]const u8{ "", "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };
    const month_name = if (month_num > 0 and month_num <= 12) month_names[month_num] else "???";

    // Use a static buffer to avoid allocation issues
    const static = struct {
        var buf: [64]u8 = undefined;
    };

    const result = std.fmt.bufPrint(&static.buf, "{s} {s} {s} {s}", .{ day, month_name, year, time }) catch return date_str;
    return result[0..result.len];
}

// Compile-time tests
test "build info formatting" {
    const testing = std.testing;

    // Test that build number is greater than 0
    try testing.expect(current_build.build_number > 0);

    // Test date format
    try testing.expect(current_build.build_date.len > 10); // Should be longer than "1970-01-01"

    // Test that the format function produces clean output
    var buf: [256]u8 = undefined;
    const formatted = try std.fmt.bufPrint(&buf, "{f}", .{current_build});

    std.debug.print("Build info format test: '{s}'\n", .{formatted});
    std.debug.print("Build number: {d}\n", .{current_build.build_number});
    std.debug.print("Build date: '{s}'\n", .{current_build.build_date});

    // Should contain "build:" and the build number
    try testing.expect(std.mem.indexOf(u8, formatted, "build:") != null);

    // Should NOT contain struct field syntax like ".build_number"
    try testing.expect(std.mem.indexOf(u8, formatted, ".build_number") == null);
    try testing.expect(std.mem.indexOf(u8, formatted, "{ ") == null);
}

test "date formatting" {
    const testing = std.testing;

    const test_date = "2025-10-15 01:14:30 UTC";
    const short_date = formatDateShort(test_date);

    // Should be in format "15 Oct 2025 01:14"
    try testing.expect(std.mem.indexOf(u8, short_date, "15 Oct 2025") != null);
    try testing.expect(std.mem.indexOf(u8, short_date, "01:14") != null);

    std.debug.print("Date format test: '{s}' -> '{s}'\n", .{ test_date, short_date });
}